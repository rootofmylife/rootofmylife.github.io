# SQLite

## A Brief History

Let's take a look back at where SQLite came from, as that can help us understand why SQLite was created in the first place and what place it has in the world of development. SQLite was written by Dr. D. Richard Hipp in 2000 while he was working on a contract for the United States Navy writing software for destroyers. He evaluated other database engines but ended up designing his own implementation.

Now SQLite is [open source](https://sqlite.org/src/timeline) ([GitHub mirror](https://github.com/sqlite/sqlite?tab=readme-ov-file)) and released to the public domain but it is not open to contributions. Dr. Hipp keeps tight control on the software and only lets a few people contribute. Notably, SQLite does not use Git but instead Fossil. [This is a nice little summary of how they differ](https://www.fossil-scm.org/home/doc/trunk/www/fossil-v-git.wiki#devorg). Fossil was created specifically by Dr. Hipp for the maintenance of SQLite (much like Git was for Linux.)

## Style

If you want data show as table, create a file at `~/.sqliterc` with content

```vi
.mode box
```

## Data type

| Column Datatype | Types Allowed In That Column |
| --------------- | ---------------------------- |
| INTEGER         | INTEGER, REAL, TEXT, BLOB    |
| REAL            | REAL, TEXT, BLOB             |
| TEXT            | TEXT, BLOB                   |
| BLOB            | INTEGER, REAL, TEXT, BLOB    |

What is indeed nice about this is that SQLite will take most SQL queries written for other databases (like MySQL, Postgres, etc.) and it will work for SQLite as SQLite will just coerce most things to a TEXT data type.

A common one in other databases is VARCHAR and SQLite will happily accept that and just make it a text field. VARCHAR usually comes with a text limit (like this field can only be 255 characters long) and SQLite will not respect those limits. So you can create a table with VARCHAR(255) and then just insert a whole page's worth of text into it, SQLite does not care.

## Import data

```bash
## Open db file from termial
cd ~/Desktop
sqlite3 ./my-chinook.db
```

```bash
## Inside sqlite
.read ./Chinook_Sqlite.sql # or where-ever you downloaded this file
.tables # you should the tables you imported from Chinook
.schema TABLE_NAME # If you need to get the name of column
```

## `SELECT`

SELECT is the name of the "command" part of the query. It's what the command is going to do. In our case, we're going to be reading from the database which is a SELECT command.

```sql
SELECT * FROM Artist;
```

## `WHERE`

In this case, we're querying all rows without any filtering whatsoever. Sometimes this is useful but normally you have an idea of some subset of rows you want. Let's say we wanted to get the ID of one of my favorite bands, The Postal Service. How would we do that?

```sql
SELECT ArtistID FROM Artist WHERE name = 'The Postal Service';
```

> Very important you use single quotes here. Single quotes mean a value or string literal. Double quotes in SQL refer to he name of columns and so putting double quotes would not be valid SQL.

## `LIKE`

Let's say you didn't know if The Postal Service was listed under "**The** Postal Service" or just "Postal Service". This is where LIKE can help.

> SQLite does not have `ILIKE`, just `LIKE`. `LIKE` is case insensitive.

```sql
SELECT ArtistID FROM Artist WHERE name LIKE '%Postal Service';
```

This will match "The Postal Service", "Postal Service", "Definitely Postal Service" and anything that has text before "Postal Service". The `%` means "give anything that matches 0 to many characters before this".

You can use multiple too. Let's say we wanted to know every band that had "Orchestra" in the name. We can do that with

```sql
SELECT name FROM Artist WHERE name LIKE '%orchestra%';
```

## `INSERT`

We've seen how to read from tables using SELECT. Let's see how to insert new data into tables using INSERT.

```sql
INSERT INTO Artist (name) VALUES ('Radiohead');
SELECT * from Artist WHERE name = 'Radiohead';
```

Notice we did not give it an ArtistId. That ID is autogenerated by SQLite for us and is guaranteed unique. If you had multiple columns, you would just make sure it's the same order on both sides

```sql
-- Not a valid query for our database, just to show you
INSERT INTO food (name, food_group, color) VALUES ('carrot', 'vegetable', 'orange'); -- notice the order is the same
```

## `UPDATE`

Let's say you didn't intend to insert the band Radiohead but instead wanted to insert Daft Punk. You could do this.

```sql
UPDATE Artist SET name = 'Daft Punk' WHERE name = 'Radiohead';
SELECT * from Artist WHERE name = 'Daft Punk';
```

Notice the IDs are the same.

### `RETURNING`

One more update, let's change it to a different French techno group

```sql
UPDATE Artist SET name = 'Justice' WHERE name = 'Daft Punk' RETURNING *;
```

The returning allows you to SELECT the rows you're updating so you can see what changed.

## `DELETE`

Very similar to UPDATEs. RETURNING also works here if you want to see what gets deleted.

```sql
DELETE FROM Artist WHERE name = 'Justice'; -- Feel free to put RETURNING * at the end
```

## `CREATE TABLE`

Let's create our first table, the `BandMember` table.

```sql
CREATE TABLE BandMember (
  id INTEGER PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  role TEXT VARCHAR
);
```

> SQLite has only four real data types: INTEGER, REAL, TEXT, and BLOB. It is a dynamically typed system. Therefore you can give datatypes like TINYINT but SQLite will just treat it like an INTEGER and likewise you can give a type of VARCHAR(255) but it will just treat it like TEXT (and therefore won't truncate it.)

Let's add multiple.

```sql
INSERT INTO
    BandMember
    (name, role)
VALUES
    ('Jonny Greenwood', 'guitarist'),
    ('Colin Greenwood', 'bassist'),
    ('Ed O''Brien', 'guitarist'),
    ('Philip Selway', 'drummer')
RETURNING *;
```

You can add multiple add a time as long as you comma separate them.

## `ALTER TABLE`

Okay so now we have a table again. What happens if we want to add a third field to our table? Let's add an `image` field that will point to a URL of an image of the person.

```sql
ALTER TABLE BandMember ADD COLUMN image TEXT;
```

Likewise we can drop it too:

```sql
ALTER TABLE BandMember DROP COLUMN image;
```

There are a lot of ways to alter a table. You can make it UNIQUE like we did or NOT NULL. You can also change the data type. For now, let's add back our extra column.

```sql
ALTER TABLE BandMember
ADD COLUMN nationality TEXT NOT NULL DEFAULT 'UK';
```

Specifying a DEFAULT when using a NOT NULL constraint will prevent errors if the column has existing null values. In this case, we're saying "add a new non-null column, and for those that exist give them the value of 'UK'."

> SQLite does not allow you to do multiple alterations in one statement. If you want to add multiple columns, you have to do multiple alter tables commands.

## `DROP TABLE`

What if we messed up and we didn't want an BandMember table?

```sql
DROP TABLE BandMember;
```

## `JOIN`

Luckily we can use relational data to have one table of bands and one table of albums.

```sql
SELECT * FROM Album LIMIT 5;
```

Notice that we're just getting ArtistId (a number) instead of the actual name of the band. That's not what we want, we want to see the name of the album and the name of the band. Enter JOINs. This allows us to join two tables based on common data. Let's see how to do that.

```sql
SELECT
    Artist.Name, Album.Title
FROM
    Album
JOIN
    Artist ON
        Album.ArtistId = Artist.ArtistId
LIMIT 5;
```

We JOIN'd the Artist table to the Album table based on them sharing a common ArtistId.

We looked at several ways of doing joins in the last section by using the `JOIN` keyword. One key thing about that is we were doing `INNER JOIN`s. If you don't specify what type of join to do, it is implicitly an INNER JOIN. In practice it didn't matter because our queries matched up 1:1:

```sql
SELECT
    B.Name, A.Title
FROM
    Album A
INNER JOIN
    Artist B ON
        A.ArtistId = B.ArtistId
LIMIT
    5;
```

> `INNER JOIN` or just `JOIN` are the same thing.

![SQLite Logo](./assets/sql_join.png)

## `FOREIGN KEY`

SQLite does not enforce foreign key rules by default. Every time you open the database connection you need to tell it respect it with `PRAGMA foreign_keys=on;`. Yes, it's by connection, and no, there's no way to always turn it on.

PRAGMAs are basically policies you can tell SQLite to respect. In this case, we are saying for _this_ connection, please enforce rules around foreign keys. You need to do this for every connection to SQLite. There's a bunch but I tend not to use too many of them.

## `VIEW`

The idea of a view is that it is an abstract or virtual table that makes use of other data in the table. A really good use case for us is that getting a list of track names with artists and albums requires two joins right now. Any time we want to get that information, we have two to write a query with two joins.

```sql
SELECT
  t.TrackId as id,
  ar.Name as artist,
  al.Title as album,
  t.Name as track
FROM
  Track t

JOIN
  Album al
ON
  t.AlbumId = al.AlbumId

JOIN
  Artist ar
ON
  ar.ArtistId = al.ArtistId

LIMIT 5;
```

This is a super usable set of data for us to list out all the tracks in a database. Now if it only wasn't so burdensome to query. Well, spoilers, it doesn't have to be. We can make a view that automatically does this for us and presents it as a pretty table.

```sql
CREATE VIEW
  easy_tracks
AS

SELECT
  t.TrackId as id,
  ar.Name as artist,
  al.Title as album,
  t.Name as track
FROM
  Track t

JOIN
  Album al
ON
  t.AlbumId = al.AlbumId

JOIN
  Artist ar
ON
  ar.ArtistId = al.ArtistId;
```

Now go ahead and `SELECT * FROM easy_tracks LIMIT 15;` to see what we did. Cool, right? We can even start doing things like joins to this table as well. If you find yourself constantly doing the same joins (like we have this whole course) views can your friend.

> SQLite does not do materialized views like Postgres. That is to say, we cannot tell SQLite "run this query and store the results" like you can in Postgres. SQLite is always querying the live data underneath.
>
> SQLite also does not support inserting into views like other databases do.

## `FTS5` (fulltext search)

What if you're building an app and you want to be able to search for "black" you expect to get the results Amy Winehouse's "Back to Black", the band Black Sabbath, and Metallica's "Black Album". Those are three different columns! We could write three LIKE queries or try to hack it around it with something similar, but luckily there's something that already exists, FTS. FTS stands for full text search and we're going to be using version 5 of it, FTS5. FTS5 is technically an extension (like the JSON one we're about to use) but FTS5 is actually shipped bundled in with SQLite now.

FTS5 allows you to run queries that look like `SELECT * FROM track_search WHERE track_search MATCH 'black'`. We get to use MATCH to tell FTS5 to look across its columns. Really cool, right?

Alright, let's re-use that View we used earlier (easy_tracks). If you don't have it anymore, here's the query to recreate it.

```sql
DROP VIEW IF EXISTS easy_tracks;
CREATE VIEW
  easy_tracks
AS

SELECT
  t.TrackId as id,
  ar.Name as artist,
  al.Title as album,
  t.Name as track
FROM
  Track t

JOIN
  Album al
ON
  t.AlbumId = al.AlbumId

JOIN
  Artist ar
ON
  ar.ArtistId = al.ArtistId;
```

Then we need to create the virtual table that will contain the full text search.

```sql
CREATE VIRTUAL TABLE track_search USING FTS5(content="easy_tracks", content_rowid='id', track, album, artist);
```

- We have to identify where the content is going to com from which will be a table. This table won't actually contain the rows but only the text searchable table that will have a rowid (which we identified as id; if you just call it rowid we don't have to tell it which rowid to use.)
- We tell it what rows we want to include in full text search. Let's say we had producers in that table as well but we didn't want that to be searchable. No problem, you could write a query to select producers that have `MATCH 'black'` and that still works fine! As long as it's in the view/table you're selecting from.
- We're choosing to index the view we created earlier but you can definitely do it on normal tables as well.

Okay, so because the table doesn't include the rows itself, we actually have to go populate it. We have to continually keep it up to date because [it does not automatically sync](https://www.sqlite.org/fts5.html#external_content_and_contentless_tables) (unlike a view.)

```sql
INSERT INTO track_search SELECT album, artist, track FROM easy_tracks;
```

This is the fastest way. We just use a select statement to grab the correct bits of info and dump it directly into track_search. In theory you could just create a cron job to continually update the virtual table every hour/day/week or whatever meets your customers' needs.

You could get extra fancy and do it with TRIGGERs which we're not going to cover in this course. If you want to see that, [this StackOverflow answer](https://stackoverflow.com/a/69981377) explains exactly how to. If you do that it'll automatically keep your FTS5 table in sync with your view.

Okay, so let's run some queries!

```sql
SELECT * FROM track_search WHERE track_search MATCH 'black';
SELECT * FROM track_search WHERE track_search = 'white';
SELECT * FROM track_search('red');
```

All of these are valid ways of writing the same query. I tend to use the `MATCH` syntax as it's very clear that it's a FTS query.
