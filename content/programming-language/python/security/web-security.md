# Web Security

## General Principles

- Security is a process, not a product.
- Have a [Defence in Depth](https://www.fortinet.com/resources/cyberglossary/defense-in-depth) approach to security with multiple layers of protection.

> Defense in depth is a strategy that leverages multiple security measures to protect an organization's assets. The thinking is that if one line of defense is compromised, additional layers exist as a backup to ensure that threats are stopped along the way.

- Never implement your own security algorithms. Use well-known and tested libraries. For example: Python's [Cryptography](https://cryptography.io/en/latest/) library.
- Data should be encrypted at rest and in transit.
  - At rest:
    - Use SQLAlchemy's [StringEncryptedType](https://pypi.org/project/SQLAlchemy-Utils/) for encrypting data in the database.
    - For Django, use [django-encrypted-fields](https://pypi.org/project/django-encrypted-model-fields/).
  - In transit:
    - Use TLS/SSL for encrypting data in transit, ensuring obsolete versions of TLS are disabled
    - Implement [zero-trust architecture](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf) to ensure that all traffic is encrypted. Use [OpenZiti](https://github.com/openziti/ziti) as a zero-trust network example.
- With AWS S3, do not publicly expose data in S3 buckets. Use [signed URLs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html) for access control.
- Use [OWASP](https://owasp.org/www-project-top-ten/) guidelines for secure coding practices.
- Use security testing techniques like [threat modelling](https://www.threatmodelingmanifesto.org/)
  - Use [OWASP Testing Guileline](https://owasp.org/www-project-web-security-testing-guide/stable/2-Introduction/) for security testing.
- Always use standart authentication and access control mechanisms. For example, use OAuth2 for authentication.
  - Applications, and therefore permissions, is more complicated than just user/admin. Use [RBAC](https://en.wikipedia.org/wiki/Role-based_access_control) for fine-grained access control.
    - Role-Based Access Control (RBAC) provides more fine-grained controls than authenticated/unauthenticated and is simpler to manage than permissions per user.
    - RBAC is a form of Access Control List (ACL). The group information stored in `/etc/group` on Linux is an example where every group is effectively also a role.
  - Use [JWT](https://jwt.io/) for stateless authentication.
  - Follow the principle of least privilege. Users should only have the permissions they need to do their job.
  - Deny by default, allow by exception.
  - Object ownership rather than roles is better for restricting access if possible (single user rather than groups)
  - Log all changes to sensitive data (auditability)
  - Manage the lifetime of all access tokens (JWTs) and make them short-lived (or follow OAuth 2 guidelines on revoking access)
  - Never store passwords in plaintext and use key derivation functions
  - Always require 2FA for login
- Use tools like [`pip-audit`](https://github.com/pypa/pip-audit), `bandit`, and `ruff` which warn of security issues, and don’t silence warnings without confirming there is no real risk (pip-audit checks dependencies for CVEs)
- Use uv’s project manage commands (uv run, uv sync, etc) , or tools with similar features like pipenv, which [hash dependencies when set and verify on install](https://docs.astral.sh/uv/concepts/projects/layout/#the-lockfile).
- Never hard code secrets in code, always use proper secrets management tools like [AWS Secrets Manager](https://aws.amazon.com/secrets-manager/), [HashiCorp Vault](https://www.vaultproject.io/), or [Keywhiz](https://square.github.io/keywhiz/), [Helm Secrets](https://helm.sh/).
- Never directly include external input in queries without sanitization (to protect against injection attacks)
  - Using prepared statements for database queries helps prevent SQL injection attacks.
  - Python-based data validation libraries, including pydantic and the Django form system, can be leveraged to validate incoming data of any format — even file-based data such as CSV and JSON files
- Use [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) to prevent cross-origin attacks.
  - By default stick to the SOP (Same Origin Policy).
  - There is middleware to configure CORS with Flask and aiohttp (etc) where you need Cross Origin Request Sharing
- Use CSRF tokens in web forms to protect against Cross Site Request Forgery
  - This should be handled for you by your web application framework
  - A single-use CSRF token is generated by the server and included as a hidden field in the form. The token must be included in a POST to be valid, or the form submission will be rejected
- Sanitise input to template rendering to protect against XSS (Cross Site Scripting) vulnerabilities (including markdown rendering)
- One of the most common causes of security vulnerabilities is memory overflow/underflow issues. So use memory-safe languages like Python and Rust

## CVEs and CWEs

Web application security classifies problems as vulnerabilities (specific exploits categorized using [CVEs](https://cve.mitre.org/): Common Vulnerabilities and Exposures) and weaknesses (potential exploits tracked using [CWEs](https://cwe.mitre.org/): Common Weakness Enumeration ). The CVE system was started in 1999 and is funded by the US [National Cyber Security Division](https://en.wikipedia.org/wiki/National_Cyber_Security_Division) of the US [Department of Homeland Security](https://en.wikipedia.org/wiki/US_Department_of_Homeland_Security).

These warning notices are the backbone of web security and tools like `pip-audit` will scan your dependencies for any known vulnerabilities from these indexes.

Container scanning can find and warn about known vulnerabilities in components of your container images. Tools like [dependabot](https://github.com/dependabot) and [renovate](https://docs.renovatebot.com/) can automate updating versions (of app dependencies and in your base OS image) as fixes become available.

## The OWASP Top Ten

The OWASP Foundation (Open Web Application Security Project) monitors the CVE and CWE indexes and curates a list of the top ten security vulnerabilities for web applications from CVE/CWE data. For a web application to be secure it must, at least, be resistant against these vulnerabilities. The current list of OWASP top ten was compiled in 2021, with an updated list due to be compiled in early 2025.

The [OWASP Top Ten](https://owasp.org/www-project-top-ten/).

## External Links

A useful primer on cryptography algorithms, principles, and concepts: [Cryptography 101](https://www.crypto101.io/)

[pyca/cryptography](https://cryptography.io/en/latest/) - A Python library which provides cryptographic recipes and primitives.

[XSS prevention for Flask | Semgrep](https://semgrep.dev/docs/cheat-sheets/flask-xss)

[Full-stack security guide](https://dzone.com/articles/full-stack-security-guide-best-practices-challenges)

## Password security

Username and password, with two-factor authentication, is the minimum standard for security and it is one of the most security-sensitive parts of a system.

You must not store passwords in plaintext. This is important.

> An attacker must not be able to get the passwords of your users by stealing your database.

To avoid storing passwords in plaintext we used to store a secure hash of the password instead and compare the hash of the user input to the stored password hash. As computation speed increased and storage costs went down it became feasible to generate massive “rainbow tables” of all the hashes of every possible password (up to a certain length) for a given hash function. This breaks the “one-way” nature of hashing algorithms and allows you to go from hash back to original input.

The next step was to salt the hashes – prepending a known “salt” (some random data) to the password before hashing and applying the same salt when checking the password. To break this a rainbow table per salt is needed. As they became more feasible to generate we switched to “key derivation functions” instead of “salt and hash” to protect passwords. Salts are not completely obsolete, they turn up in other cryptographic algorithms as we saw with Ferret encryption.

The state of the art changes over time; the easiest way to deal with this is to use a secure web application framework to handle login management for you, or delegate to an identity provider like Azure AD and use a common protocol like OAuth2 for authentication.

## Tools

Tools that can help as part of development:

- `bandit` – checks for common security vulnerabilities
- `ruff`, `flake8`, etc – these can check for some vulnerabilities, like injection attacks. ruff replaces tools like black and flake8 and is working towards replacing bandit too
- `pip-audit` – scans dependencies for CVE vulnerabilities
- `mypy` – static type analysis (code correctness is a security issue)
- `deptry`/`grimp` – tools that can be used to analyse dependencies within a project to help find unused dependencies

[Source](https://opensource.net/essential-python-web-security/)
